# React & Next.js Best Practices for Saffari-Raahi Project

## Component Structure
- Use functional components with hooks instead of class components
- Keep components small and focused on a single responsibility
- Export components as named exports, not default exports

## Atomic Design Principles
- Atoms: Basic building blocks (buttons, inputs, labels)
  - Should be highly reusable and have minimal dependencies
  - Focus on a single UI element with appropriate props for customization
  - Example: Button.tsx, Input.tsx, Label.tsx
- Molecules: Groups of atoms that work together
  - Combine multiple atoms to create more complex components
  - Should still be relatively simple and reusable
  - Example: SearchBar.tsx (combines Input and Button atoms)
- Organisms: Complex UI components composed of molecules and atoms
  - Represent distinct sections of the interface
  - May contain business logic and state management
  - Example: NavigationBar.tsx, BookingForm.tsx
- Templates: Page layouts that arrange organisms
  - Define the structure of a page without specific content
  - Handle responsive layout and positioning
  - Example: DashboardTemplate.tsx, CheckoutTemplate.tsx
- Pages: Specific instances of templates with real content
  - Connect to data sources and handle routing
  - Assemble the required organisms within templates
  - Example: HomePage.tsx, BookingPage.tsx

## State Management
- Use React hooks (useState, useReducer) for local component state
- Prefer React Query for server state management
- Avoid prop drilling by using context or state management libraries
- Keep state as close as possible to where it's used

## Performance
- Use React.memo for expensive components that render often
- Implement useMemo and useCallback for optimizing renders
- Avoid unnecessary re-renders by proper dependency arrays in useEffect
- Use Next.js Image component for optimized images

## Routing
- Use Next.js App Router conventions
- Implement proper loading and error states for routes
- Use dynamic imports for code splitting
- Keep page components clean by moving logic to custom hooks

## Styling
- Use Tailwind CSS for styling
- Follow mobile-first responsive design
- Maintain consistent spacing and color schemes
- Use CSS variables for theming

## Data Fetching
- All API calls should be made using the `apiClient` utility.
- Utilize React Query's `useQuery` for fetching data and `useMutation` for data modifications.
- Implement proper loading and error states
- Use Next.js API routes for backend functionality
- Handle API errors gracefully

## Forms
- Validate user input both client and server side
- Provide clear feedback for form errors
- Use controlled components for form inputs
- Implement proper form submission handling

## Accessibility
- Use semantic HTML elements
- Ensure proper keyboard navigation
- Include proper ARIA attributes
- Maintain sufficient color contrast

## Code Quality
- Follow consistent naming conventions
- Write unit tests for critical components
- Use TypeScript for type safety
- Document complex logic with comments

## Project Structure
- Follow Next.js App Router directory structure
- Group related files in feature-based directories
- Use barrel files (index.ts) for clean imports
- Keep configuration files at the root level

## UI/UX Principles
- Visual Hierarchy
  - Establish clear visual hierarchy with size, color, and spacing
  - Highlight the most important elements and actions
  - Use consistent heading levels (h1, h2, h3) for proper content structure
  - Maintain proper spacing between related and unrelated elements

- User Flow
  - Design intuitive navigation paths with clear progression
  - Minimize the number of steps to complete common tasks
  - Provide clear visual cues for the current step in multi-step processes
  - Use breadcrumbs for complex navigation structures
  - Implement predictable back/forward navigation

- Feedback & Affordance
  - Provide immediate feedback for user actions (button states, loading indicators)
  - Use appropriate hover and focus states for interactive elements
  - Display clear success/error messages after form submissions
  - Implement skeleton loaders for content that takes time to load
  - Use tooltips for explaining complex features

- Consistency
  - Maintain consistent component styling across the application
  - Use the same interaction patterns for similar actions
  - Apply consistent spacing, typography, and color schemes
  - Follow established UI patterns that users are familiar with

- Mobile Responsiveness
  - Design for mobile-first, then adapt to larger screens
  - Ensure touch targets are at least 44x44px on mobile devices
  - Adapt layouts appropriately for different screen sizes
  - Test on various devices and screen resolutions

- Error Prevention & Recovery
  - Validate inputs in real-time with helpful error messages
  - Provide clear recovery paths when errors occur
  - Confirm destructive actions before execution
  - Implement auto-save where appropriate
  - Allow users to undo recent actions when possible
